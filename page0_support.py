#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.1
#  in conjunction with Tcl version 8.6
#    May 10, 2021 01:19:01 PM CST  platform: Windows NT

import sys
from glob import glob
import os
import webbrowser,wave,requests,time,base64
import mysql.connector
import wavio
from librosa.core import resample, to_mono
import numpy as np
import pandas as pd

from tensorflow.keras.models import load_model
from kapre.time_frequency import STFT, Magnitude, ApplyFilterbank, MagnitudeToDecibel
from sklearn.preprocessing import LabelEncoder

try:
    import Tkinter as tk
    from tkinter import messagebox
    from tkinter.filedialog import *
except ImportError:
    import tkinter as tk
    from tkinter import messagebox
    from tkinter.filedialog import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True



def set_Tk_var():
    global combobox
    combobox = tk.StringVar()


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

def downsample_mono(path, sr):
    obj = wavio.read(path)
    wav = obj.data.astype(np.float32, order='F')
    rate = obj.rate
    try:
        channel = wav.shape[1]
        if channel == 2:
            wav = to_mono(wav.T)
        elif channel == 1:
            wav = to_mono(wav.reshape(-1))
    except IndexError:
        wav = to_mono(wav.reshape(-1))
        pass
    except Exception as exc:
        raise exc
    wav = resample(wav, orig_sr=rate, target_sr=sr)
    wav = wav.astype(np.int16)
    return sr, wav

def prediction(audiopath):
    model = load_model('model/conv2d.h5',
    custom_objects={'STFT':STFT,
                    'Magnitude':Magnitude,
                    'ApplyFilterbank':ApplyFilterbank,
                    'MagnitudeToDecibel':MagnitudeToDecibel})
    rate, wav = downsample_mono(audiopath, 16000)
    batch = []
    step = int(16000*2.0)
    for i in range(0, wav.shape[0], step):
        sample = wav[i:i+step]
        sample = sample.reshape(-1, 1)
        if sample.shape[0] < step:
            tmp = np.zeros(shape=(step, 1), dtype=np.float32)
            tmp[:sample.shape[0],:] = sample.flatten().reshape(-1, 1)
            sample = tmp
        batch.append(sample)
    X_batch = np.array(batch, dtype=np.float32)
    y_pred = model.predict(X_batch)
    y_mean = np.mean(y_pred, axis=0)
    y_pred = np.argmax(y_mean)
    list = ['玻璃瓶','草稿纸','干电池','瓜子壳','过期药品','海绵','旧衣服','口罩','猫砂','牛奶盒','塑料袋','头发',
        '卫生纸','小票','烟头']
    return list[y_pred],y_mean[y_pred]

###############################bai du #########################################
def get_devpid(v):
    global devpid
    if v == "普通话（默认）":
        devpid = 1536
    elif v == "普通话（带标点）":
        devpid = 1567
    elif v == "英语":
        devpid = 1737
    elif v == "粤语":
        devpid = 1637
    elif v == "四川话":
        devpid = 1837
    else:
        devpid = 1536
    return devpid


def baidu_api(devpid,audiopath):
    base_url = "https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&client_id=%s&client_secret=%s"
    APIKey = "0QKwKuAxo0u2fQZsAftmX0jc"
    SecretKey = "PdhfonU6eYYKeW5qfdqgzEUGxhE92hdG"
    # 获取token
    HOST = base_url % (APIKey, SecretKey)
    res = requests.post(HOST)
    TOKEN = res.json()['access_token']
    # 读入wav
    with open(audiopath, 'rb') as f:
        speech_data = f.read()
    try:
        FORMAT = 'wav'
        RATE = '16000'
        CHANNEL = 1
        CUID = '*******'
        SPEECH = base64.b64encode(speech_data).decode('utf-8')

        data = {
            'format': FORMAT,
            'rate': RATE,
            'channel': CHANNEL,
            'cuid': CUID,
            'len': len(speech_data),
            'speech': SPEECH,
            'token': TOKEN,
            'dev_pid': devpid
        }
        url = 'https://vop.baidu.com/server_api'
        headers = {'Content-Type': 'application/json'}
        # r=requests.post(url,data=json.dumps(data),headers=headers)
        r = requests.post(url, json=data, headers=headers)
        Result = r.json()
        if 'result' in Result:
            return Result['result'][0]
        else:
            return Result
    except:
        return '未能正确识别，请重试'

############################## 数据库操作 #####################################
#连接数据库
def dbConnect(db_host):
    db_user = 'root'
    db_pass = '12345%$#@!'
    db_name = 'pythondb'
    db_conn = mysql.connector.connect(user=db_user,password=db_pass,host=db_host,database=db_name)
    return db_conn

#获取数据
def sqlOpt(rubbish_name):
    db_conn = dbConnect('localhost')
    sql = "select * from pythondb.rubbishes where Name = '{}'".format(rubbish_name)
    try:
        cursor = db_conn.cursor()
        cursor.execute(sql)
        result=cursor.fetchall()
        index={1:'可回收物',2:'有害垃圾',4:'厨余垃圾',8:'其他垃圾'}
        return(str(index.get(result[0][1],'大件垃圾')))
    except:
        return('未知垃圾')
    finally:
        db_conn.close()
        
#增添/修改数据
def sqlInsert(rubbish_name,class_name):
    db_conn = dbConnect('localhost')
    index={'可回收物':1,'有害垃圾':2,'厨余垃圾':4,'其他垃圾':8}
    val = (rubbish_name,index[class_name])
    sql = "INSERT ignore INTO rubbishes (name,class) values {}".format(val)
    try:
        cursor = db_conn.cursor()
        cursor.execute(sql)
        db_conn.commit()
        return True
    except:
        return False
    finally:
        db_conn.close()

#删除数据
def sqlDel(rubbish_name):
    db_conn = dbConnect('localhost')
    na = (rubbish_name,)
    sql = "DELETE FROM pythondb.rubbishes WHERE Name = %s"
    try:
        cursor = db_conn.cursor()
        cursor.execute(sql,na)
        db_conn.commit()
        return True
    except:
        return False
    finally:
        db_conn.close()
################################################################################

def find(result):
    value = sqlOpt(result)
    if value == "可回收物":
        kepu = " \0\0可回收物指适宜回收利用和资源化利用的生活废弃物。\n\0\0可回收物主要类别包括：废纸、废弃塑料瓶、废金属、废包装物、废旧纺织物、废弃电器电子产品、废玻璃、废纸塑铝复合包装等。"
    elif value == "有害垃圾":
        kepu = "\0\0有害垃圾指生活垃圾中对人体健康、自然环境造成直接或潜在危害的废弃物。\n\0\0有害垃圾主要类别包括：废电池类、废荧光灯管类、废温度计类、废药品类、废油漆类、废杀虫剂类、废胶片以及废相纸类。"
    elif value == "厨余垃圾":
        kepu = "\0\0厨余垃圾指居民日常生活食品加工及餐后产生的易粉碎、易腐有机垃圾。\n\0\0厨余垃圾主要类别包括：食材废料、剩菜剩饭、废弃食品废料、瓜皮果核、室内绿植花卉等。"
    elif value == "其他垃圾":
        kepu = "\0\0其他垃圾指除厨余垃圾、可回收物、有害垃圾之外的生活垃圾。\n\0\0其他垃圾主要类别包括：砖瓦陶瓷、渣土、卫生间废纸、瓷器碎片、动物排泄物、一次性用品等难以回收的废弃物。"
    elif value == "大件垃圾":
        kepu = "\0\0大件垃圾是指体积较大、整体性强，需要拆分再处理的废弃物品。包括废家用电器和家具等。"
    else:
        kepu = "抱歉，有以下情况：\n1.小海没有听懂您说的垃圾；\n2.您搜索的词汇未收录词库里；\n请您手动搜索或再说一遍"
    return value,kepu


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import page0
    page0.vp_start_gui()




